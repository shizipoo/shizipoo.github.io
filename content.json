{"pages":[{"title":"","text":"404","link":"/about/404.html"},{"title":"about","text":"欢迎来到大理！！！","link":"/about/index.html"}],"posts":[{"title":"Markdown语法","text":"标题 直接通过#号的个数来控制标题级别 1234# 标题一## 标题二### 标题三#### 标题四 效果如下所示： 标题一标题二标题三标题四 字体1234*斜体***加粗*****斜体加粗***~~删除线~~ 效果如下所示：斜体加粗斜体加粗删除线 图片1![棒棒哒](http://pydi4imsi.bkt.clouddn.com/1001.jpg &quot;猫咪ok&quot;) 效果如下所示： 超链接1参考链接：[https://www.jianshu.com/p/191d1e21f7ed](https://www.jianshu.com/p/191d1e21f7ed) 效果如下所示：参考链接：https://www.jianshu.com/p/191d1e21f7ed 表格12345|姓名|性别|年龄||:-|:--:|--:| #|:-| 代表左对齐; :-:| 代表居中; -:| 代表右对齐|张三|男|5||李四|男|10||小花|女|18| 效果如下所示： 姓名 性别 年龄 张三 男 5 李四 男 10 小花 女 18 引用12&gt;你猜&gt;&gt;你猜 效果如下所示： 你猜 你猜 分割线12---*** 效果如下所示： 列表有序列表12341. java2. python3. Go4. C++ 效果如下所示： java python Go C++ 无序列表1234- java- python- GO- C++ 效果如下所示： java python GO C++ 列表嵌套1234567891011121314151617181920- java - java - python - Go - C++ - java - python - Go - C++- python 1. java 2. python 3. Go 4. C++ 1. java 2. python 3. Go 4. C++- Go- C++ 效果如下所示： java java python Go C++ java python Go C++ python java python Go C++ java python Go C++ Go C++ 下一级列表缩减3个空格，与上一级列表进行区分 代码（1）代码块：缩进 4 个空格或是 1 个制表符。效果如下：（2）行内式：如果在一个行内需要引用代码，只要用反引号`引起来就好（一般在ESC键下方，和~同一个键）（3）多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号“`”包裹，就可以了。 1`` #单行代码使用反引号即可 效果如下所示： 1&amp;#9786 特殊符号 （1）对于 Markdown 中的语法符号，前面加反斜线\\即可显示符号本身。 （2）其他特殊字符，示例如下： 12&amp;#9813;&amp;#9784; 效果如下所示： ♕☸ 参考链接：字符百科 常用技巧 字体、字号与颜色 123&lt;font color=#FF0000 size=4 face=&quot;黑体&quot; &gt;报错&lt;/font&gt; #color 设置颜色，size 设置字体大小（1~7），face 设置字体&lt;b&gt;内容&lt;/b&gt; #加粗&lt;strong&gt;内容&lt;/strong&gt; #强调 效果如下： 报错 可以配合markdown自己语言的加粗和斜体对字体进行设置。 流程图 123456789st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?op1=&gt;operation: My Operation1e=&gt;end: 结果st-&gt;op-&gt;op1-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; Typora 快捷键：https://www.cnblogs.com/hongdada/p/9776547.html","link":"/2019/11/04/Markdown%E8%AF%AD%E6%B3%95/"},{"title":"bamdst使用方法","text":"Bamdst 是一个轻量级工具，用来统计bam文件的目标区域深度覆盖。Bam 文件需要进行排序，bed文件和输出路径必须进行指定。Github地址：https://github.com/shiquan/bamdst 常规：bamdst -p &lt;probe.bed&gt; -o ./ in1.bam管道模式：samtools view in1.bam -u | bamdst -p x.bed -o ./ -参数：-o / --outdir [dir] 设置输出路径 [强制] -p / --bed [file] 探针或目标区域文件，这些区域需要合并 [强制]可选参数：-f / --flank [num] 如果你想计算侧翼区域的覆盖度，设置这个值，默认值200。 --maxdepth [num] 对于一些项目，特殊区域的深度非常高，如果你不想在分布文件中显示这些不正常的深度，设置阈值去过滤它们。默认值是0（不过滤）。 --cutoffdepth [num] 对于一些项目，人们关注特定深度的覆盖度，比如10000X。bamdst 仅仅计算0x, 4x, 10x, 30x, 100x的覆盖度 ，所以你可以设置这个值，在coverage.report 文件中会显示特定的覆盖度。默认值0。 --isize [num] 对于比对率差的双端读长，推断的插入片段大小非常大。为了合理的可视化目的可以设置一个阈值。默认值2000。 --uncover [num] 为了计算覆盖度不好的区域，设置这个阈值。默认是&lt;5。 --use_rmdup (v1.0.0以后的一个可用参数 ) 使用rmdup depth代替cover depth来计算目标区域的覆盖度。输出文件：输出文件夹中会有7个文件。它们是： -coverage.report 这个文件包含目标区域和侧翼区域的所有覆盖度信息，输入文件的reads信息。 -cumu.plot 深度分布图 -insert.plot 推断的插入片段大小分布图 -chromosome.report 每一条染色体的深度和覆盖度信息 -region.tsv.gz 对于bed文件中的每一个区域，平均深度，中位深度和这个区域的覆盖度将显示在这个文件中。 -depth.tsv.gz 对于探针文件（bed）的每一个位置，三种深度值将被计算，包括raw depth , rmdup depth 和coverage depth 。raw depth 从bam文件中检索，没有任何限制。rmdup depth 计算去除重复reads，二次比对reads和低map质量reads(mapQ&lt;20) ，这个值与samtools depth 的输出结果很相似。coverage depth 是考虑了缺失区域的raw depth ，所以它的值应该大于或等于raw depth 。我们用raw depth 来评估 coverage.report文件中的覆盖度信息。如果你想用rmdup depth 来计算覆盖度，请使用 &quot;--use_rmdup&quot;参数。 -uncover.bed 此bed文件中包含bam文件比对探针文件，不好的覆盖和没有覆盖的区域。通过“--uncover”来设置uncover的阈值。","link":"/2019/11/04/bamdst%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"django","text":"安装python3123456wget https://www.python.org/ftp/python/3.6.9/Python-3.6.9.tgztar -xzvf Python-3.6.9.tgzcd Python-3.6.9./configure --with-sslmakesudo make install 安装Django 方法一1sudo pip3 install Django==2.1 方法二 (此方法安装的为最新版本)12git clone https://github.com/django/django.gitsudo pip3 install -e ./django 检测模块是否安装成功1python3 -c \"import django;print(django.get_version())\" 如果安装django2.2以上版本，需要安装SQLite 3.8.3以上版本 创建项目1234mkdir myprojectcd myprojectdjango-admin startproject mysite .python3 manage.py runserver 报错 运行的python3 manage.py runserver出现了报错，django.db.utils.NotSupportedError: URIs not supported，是SQLite 的原因，SQLite 3.8以前的版本都有这个问题。 查看SQLite的版本，命令如下： 123456$ sqlite3 --version3.6.20$ python3 -c \"import sqlite3; print(sqlite3.version)\"2.6.0$ python3 -c \"import sqlite3; print(sqlite3.sqlite_version)\"3.6.20 解决办法：修改/usr/local/lib/python3.6/site-packages/django/db/backends/sqlite3/base.py的155行的’uri’: True ，True 该给False。 12155 kwargs.update({'check_same_thread': False, 'uri': True})156 return kwargs 然后重新运行python3 manage.py runserver 然后在浏览器中输入 http://127.0.0.1:8000/ 即可看到django创建的网页 但是如果在服务器上，需要修改settings.py脚本中的host地址， 12345678910111213.├── db.sqlite3├── manage.py└── mysite ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-36.pyc │ ├── settings.cpython-36.pyc │ ├── urls.cpython-36.pyc │ └── wsgi.cpython-36.pyc ├── settings.py ├── urls.py └── wsgi.py 将ALLOWED_HOSTS = [] 改为 ALLOWED_HOSTS = ['172.26.0.23'] 然后运行python3 manage.py runserver 0.0.0.0:8000然后在浏览器中输入http://172.26.0.23:8000/ 即可看到django创建的网页 创建应用1234567891011121314151617181920212223python3 manage.py startapp blog.├── blog│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ │ └── __init__.py│ ├── models.py│ ├── tests.py│ └── views.py├── db.sqlite3├── manage.py└── mysite ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-36.pyc │ ├── settings.cpython-36.pyc │ ├── urls.cpython-36.pyc │ └── wsgi.cpython-36.pyc ├── settings.py ├── urls.py └── wsgi.py 创建完应用，需要进行如下配置： 设置 ./mysite/setttings.py文件，添加blog应用： 123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog',] 设置 ./blog/models.py文件，其实就是设置数据储存的字段： 12345678910111213141516from django.db import modelsfrom django.utils import timezonefrom django.contrib.auth.models import User# Create your models here.class BlogArticles(models.Model): title = models.CharField(max_length=300) author = models.ForeignKey(User, related_name=\"blog_posts\", on_delete=models.CASCADE) body = models.TextField() publish = models.DateTimeField(default=timezone.now) class Meta: ordering = (\"-publish\",) def __str__(self): return self.title 运行 python3 manage.py makemigrations 创建模型 运行python3 manage.py migrate 创建数据库 发布博客文章 首先要创建超级用户，设置用户名，邮箱和密码。 1python3 manage.py createsuperuser 然后运行python3 manage.py runserver 0.0.0.0:8000在浏览其中输入http://172.26.0.23:8000/admin/ 就会出现下面的界面：输入刚刚设置的账户和密码即可登录，登录完成的界面如下所示： 要想发表博客，需要做如下设置：编写./blog/admin.py: 12345678910111213from django.contrib import adminfrom .models import BlogArticles# Register your models here.class BlogArticlesAdmin(admin.ModelAdmin): list_display = (\"title\", \"author\", \"publish\") list_filter = (\"publish\", \"author\") search_fields = ('title', \"body\") raw_id_fields = (\"author\",) date_hierarchy = \"publish\" ordering = ['publish','author']admin.site.register(BlogArticles,BlogArticlesAdmin) 刷新页面，就可以看到发布博客的位置： 显示博客信息 显示文章标题 配置./blog/views.py1234567from django.shortcuts import renderfrom .models import BlogArticles# Create your views here.def blog_title(request): blogs = BlogArticles.objects.all() return render(request, \"blog/titles.html\", {\"blogs\":blogs}) 在./blog/文件夹下创建templates文件夹，并创建如下文件：1234templates├── base.html└── blog └── titles.html 修改base.html文件：12345678910111213141516171819&lt;! DOCTYPE html&gt;&lt;html lang=\"zh-cn\"&gt;&lt;head&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://necolas.github.io/normalize.css/\"&gt; &lt;link rel=\"stylesheet\" href=\"http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; {% block content %} {% endblock %}&lt;/div&gt;&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://libs.baidu.com/boostrap/3.0.3/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 修改./templates/blog/titles.html文件：123456789101112131415161718192021{% extends \"base.html\" %}{% block title %}blog titles{% endblock %}{% block content %}&lt;div class=\"row text-center vertical-middle-sm\"&gt; &lt;h1&gt;我的博客&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-12 col-md-8\"&gt; &lt;ul&gt; {% for blog in blogs %} &lt;li&gt;{{ blog.title }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-md-4\"&gt; &lt;h2&gt;广告&lt;/h2&gt; &lt;p&gt;跟老齐学：www.itdiffer.com&lt;/p&gt; &lt;img width=\"200px\" src=\"http://pydi4imsi.bkt.clouddn.com/1001.jpg\"&gt; &lt;/div&gt;&lt;/div&gt;{% endblock %} 修改./mysite/urls.py文件：1234567from django.contrib import adminfrom django.conf.urls import url,includeurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')),] 修改./blog/urls.py文件：123456from django.conf.urls import urlfrom . import viewsurlpatterns=[ url(r'^$', views.blog_title, name=\"blog_title\"),] 然后在浏览器中输入http://172.26.0.23:8000/blog/即可看到如下界面： 查看文章内容 修改titles.html： 123{% for blog in blogs %} &lt;li&gt;&lt;a href=\"{{ blog.id }}\"&gt;{{ blog.title }}&lt;/a&gt;&lt;/li&gt;{% endfor %} 在./blog/views.py中添加文章请求的函数blog_article(): 1234def blog_article(request, article_id): article = BlogArticles.objects.get(id=article_id) pub = article.publish return render(request, \"blog/content.html\", {\"article\":article , \"publish\":pub }) 创建模板./templates/blog/content.html文件： 123456789101112131415161718{% extends \"base.html\" %}{% block title %}blog article{% endblock %}{% block content %}&lt;div class=\"row text-center vertical-middke-sm\"&gt; &lt;h1&gt;{{ article.title }}&lt;/h1&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-12 col-md-8\"&gt; &lt;p class=\"text-center\"&gt;&lt;span&gt;{{ article.author.username }} &lt;/span&gt;&lt;span style=\"margin-left:20px\"&gt;{{ article.publish }}&lt;/span&gt;&lt;/p&gt; &lt;div&gt;{{ article.body }}&lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-md-4\"&gt; &lt;h2&gt;广告&lt;/h2&gt; &lt;p&gt;跟老齐学：www.itdiffer.com&lt;/p&gt; &lt;img width=\"200px\" src=\"http://pydi4imsi.bkt.clouddn.com/1001.jpg\"&gt; &lt;/div&gt;&lt;/div&gt;{% endblock %} 修改./blog/urls.py 1234567from django.conf.urls import urlfrom . import viewsurlpatterns=[ url(r'^$', views.blog_title, name=\"blog_title\"), url(r'(?P&lt;article_id&gt;\\d)/$', views.blog_article, name=\"blog_detail\"),] 然后刷新页面，点击文章标题，即可出现下面的界面： django的MTV M: 模型（Model），即数据存取层，模型是网站项目的基础，主要负责处理与数据相关的事务，如读取、写入数据等。 T:模板（Template）,即表现层，处理与表现相关的事务，例如如何在页面中显示相关内容。 V:视图（Views），即业务逻辑层，包含存取模型及调取相应模板的相关逻辑， 是 M （模型）和 T （模板）之间的桥梁。当 Django 得到用户的请求后，根据 URL 映射关系调用相应的视图，视图则调用和处理有关数据。与模板相比，视图确定访问者能看到哪些数据，而模板确定怎么看到这些数据（或者说用什么方式看到这些数据）。 参考链接：https://simpleisbetterthancomplex.com/series/beginners-guide/1.11/","link":"/2019/10/29/django/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/29/hello-world/"},{"title":"snakemake","text":"优点 适用于多样品分析流程，可以对多个样品的流程进行拆分，并对每一步的CPU，内存进行限制； 对任务个数，总CPU进行限制； 对中间文件的删除和保护； 根据输入，输出及时间戳来控制模块的先后顺序； 适用于PBS,LFS,qsub,slurm等资源管理系统。 相同功能的工具有qsub-pbs ,sjm等。 规则：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667rule FastqToSam_cf: input: fwd= rawdir + &quot;/&quot; + cf_fwd, rev= rawdir + &quot;/&quot; + cf_rev output: temp(pre + &quot;/&quot; + pre + &quot;.01.unmaped.bam&quot;) params: tmp_dir=TMP_DIR, prefix=pre log: pre + &quot;/&quot; + pre + &quot;_log/log1.&quot; + pre + &quot;.FastqToSam&quot; benchmark: &quot;benchmarks/&quot; + pre + &quot;.FastqToSam.benchmark.txt&quot; threads:2 shell:&quot;&quot;&quot; gatk FastqToSam \\ -F1 {input.fwd} \\ -F2 {input.rev} \\ -O {output} \\ --TMP_DIR {params.tmp_dir} \\ -SM {params.prefix} \\ -RG KAPA \\ -PL illumina &amp;&gt; {log} &quot;&quot;&quot;rule ExtractUmisFromBam_cf: input: pre + &quot;/&quot; + pre + &quot;.01.unmaped.bam&quot; output: temp(pre + &quot;/&quot; + pre + &quot;.02.unmapped.withUMI.bam&quot;) params: tmp_dir=TMP_DIR, fgbio=FGBIO log: pre + &quot;/&quot; + pre + &quot;_log/log2.&quot; + pre + &quot;.ExtractUmisFromBam&quot; benchmark: &quot;benchmarks/&quot; + pre + &quot;.ExtractUmisFromBam.benchmark.txt&quot; threads:2 shell:&quot;&quot;&quot; java -Djava.io.tmpdir={params.tmp_dir} -Xmx4g -jar {params.fgbio} ExtractUmisFromBam \\ --input {input} \\ --output {output} \\ --read-structure 3M2S146T 3M2S146T \\ --molecular-index-tags ZA ZB \\ --single-tag RX \\ &amp;&gt; {log} &quot;&quot;&quot;rule SamToFastq_cf: input: pre + &quot;/&quot; + pre + &quot;.02.unmapped.withUMI.bam&quot; output: temp(pre + &quot;/&quot; + pre + &quot;.03.unmapped.withUMI.fastq&quot;) params: tmp_dir=TMP_DIR log: pre + &quot;/&quot; + pre + &quot;_log/log3.&quot; + pre + &quot;.SamToFastq&quot; benchmark: &quot;benchmarks/&quot; + pre + &quot;.SamToFastq.benchmark.txt&quot; threads:2 shell:&quot;&quot;&quot; gatk SamToFastq \\ -I {input} \\ -F {output} \\ --INTERLEAVE true \\ --TMP_DIR {params.tmp_dir} &amp;&gt; {log} &quot;&quot;&quot; 投递任务1snakemake -s Snakefile --cluster &quot;sbatch -N 1 -n {threads} -p node2 &quot; -j 5 -c 100 流程图 对启健流程的优化 服务器CPU 利用率提高 单位CPU内分析样品量增加 测试70个启健样品，c02（192核），CPU占用情况如下所示： 结果：20h左右可以完成分析，16hCPU开始出现空余，即可对其他数据进行分析。","link":"/2019/10/29/snakemake/"}],"tags":[{"name":"杂","slug":"杂","link":"/tags/%E6%9D%82/"},{"name":"NGS","slug":"NGS","link":"/tags/NGS/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"snakemake","slug":"snakemake","link":"/tags/snakemake/"}],"categories":[]}